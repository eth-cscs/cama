import {
  __commonJS
} from "./chunk-RSJERJUL.js";

// node_modules/xterm-addon-attach/lib/xterm-addon-attach.js
var require_xterm_addon_attach = __commonJS({
  "node_modules/xterm-addon-attach/lib/xterm-addon-attach.js"(exports, module) {
    !function(e, t) {
      "object" == typeof exports && "object" == typeof module ? module.exports = t() : "function" == typeof define && define.amd ? define([], t) : "object" == typeof exports ? exports.AttachAddon = t() : e.AttachAddon = t();
    }(self, function() {
      return (() => {
        "use strict";
        var e = {};
        return (() => {
          var t = e;
          function s(e2, t2, s2) {
            return e2.addEventListener(t2, s2), { dispose: () => {
              s2 && e2.removeEventListener(t2, s2);
            } };
          }
          Object.defineProperty(t, "__esModule", { value: true }), t.AttachAddon = void 0, t.AttachAddon = class {
            constructor(e2, t2) {
              this._disposables = [], this._socket = e2, this._socket.binaryType = "arraybuffer", this._bidirectional = !(t2 && false === t2.bidirectional);
            }
            activate(e2) {
              this._disposables.push(s(this._socket, "message", (t2) => {
                const s2 = t2.data;
                e2.write("string" == typeof s2 ? s2 : new Uint8Array(s2));
              })), this._bidirectional && (this._disposables.push(e2.onData((e3) => this._sendData(e3))), this._disposables.push(e2.onBinary((e3) => this._sendBinary(e3)))), this._disposables.push(s(this._socket, "close", () => this.dispose())), this._disposables.push(s(this._socket, "error", () => this.dispose()));
            }
            dispose() {
              for (const e2 of this._disposables)
                e2.dispose();
            }
            _sendData(e2) {
              this._checkOpenSocket() && this._socket.send(e2);
            }
            _sendBinary(e2) {
              if (!this._checkOpenSocket())
                return;
              const t2 = new Uint8Array(e2.length);
              for (let s2 = 0; s2 < e2.length; ++s2)
                t2[s2] = 255 & e2.charCodeAt(s2);
              this._socket.send(t2);
            }
            _checkOpenSocket() {
              switch (this._socket.readyState) {
                case WebSocket.OPEN:
                  return true;
                case WebSocket.CONNECTING:
                  throw new Error("Attach addon was loaded before socket was open");
                case WebSocket.CLOSING:
                  return console.warn("Attach addon socket is closing"), false;
                case WebSocket.CLOSED:
                  throw new Error("Attach addon socket is closed");
                default:
                  throw new Error("Unexpected socket state");
              }
            }
          };
        })(), e;
      })();
    });
  }
});
export default require_xterm_addon_attach();
//# sourceMappingURL=xterm-addon-attach.js.map
