{
  "version": 3,
  "sources": ["../../xterm-addon-attach/lib/webpack:/AttachAddon/webpack/universalModuleDefinition", "../../xterm-addon-attach/lib/webpack:/AttachAddon/src/AttachAddon.ts"],
  "sourcesContent": ["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"AttachAddon\"] = factory();\n\telse\n\t\troot[\"AttachAddon\"] = factory();\n})(self, function() {\nreturn ", "/**\n * Copyright (c) 2014, 2019 The xterm.js authors. All rights reserved.\n * @license MIT\n *\n * Implements the attach method, that attaches the terminal to a WebSocket stream.\n */\n\nimport { Terminal, IDisposable, ITerminalAddon } from 'xterm';\n\ninterface IAttachOptions {\n  bidirectional?: boolean;\n}\n\nexport class AttachAddon implements ITerminalAddon {\n  private _socket: WebSocket;\n  private _bidirectional: boolean;\n  private _disposables: IDisposable[] = [];\n\n  constructor(socket: WebSocket, options?: IAttachOptions) {\n    this._socket = socket;\n    // always set binary type to arraybuffer, we do not handle blobs\n    this._socket.binaryType = 'arraybuffer';\n    this._bidirectional = !(options && options.bidirectional === false);\n  }\n\n  public activate(terminal: Terminal): void {\n    this._disposables.push(\n      addSocketListener(this._socket, 'message', ev => {\n        const data: ArrayBuffer | string = ev.data;\n        terminal.write(typeof data === 'string' ? data : new Uint8Array(data));\n      })\n    );\n\n    if (this._bidirectional) {\n      this._disposables.push(terminal.onData(data => this._sendData(data)));\n      this._disposables.push(terminal.onBinary(data => this._sendBinary(data)));\n    }\n\n    this._disposables.push(addSocketListener(this._socket, 'close', () => this.dispose()));\n    this._disposables.push(addSocketListener(this._socket, 'error', () => this.dispose()));\n  }\n\n  public dispose(): void {\n    for (const d of this._disposables) {\n      d.dispose();\n    }\n  }\n\n  private _sendData(data: string): void {\n    if (!this._checkOpenSocket()) {\n      return;\n    }\n    this._socket.send(data);\n  }\n\n  private _sendBinary(data: string): void {\n    if (!this._checkOpenSocket()) {\n      return;\n    }\n    const buffer = new Uint8Array(data.length);\n    for (let i = 0; i < data.length; ++i) {\n      buffer[i] = data.charCodeAt(i) & 255;\n    }\n    this._socket.send(buffer);\n  }\n\n  private _checkOpenSocket(): boolean {\n    switch (this._socket.readyState) {\n      case WebSocket.OPEN:\n        return true;\n      case WebSocket.CONNECTING:\n        throw new Error('Attach addon was loaded before socket was open');\n      case WebSocket.CLOSING:\n        console.warn('Attach addon socket is closing');\n        return false;\n      case WebSocket.CLOSED:\n        throw new Error('Attach addon socket is closed');\n      default:\n        throw new Error('Unexpected socket state');\n    }\n  }\n}\n\nfunction addSocketListener<K extends keyof WebSocketEventMap>(socket: WebSocket, type: K, handler: (this: WebSocket, ev: WebSocketEventMap[K]) => any): IDisposable {\n  socket.addEventListener(type, handler);\n  return {\n    dispose: () => {\n      if (!handler) {\n        // Already disposed\n        return;\n      }\n      socket.removeEventListener(type, handler);\n    }\n  };\n}\n"],
  "mappings": ";;;;;;;KAAA,SAA2CA,GAAMC,GAAAA;AAC1B,kBAAA,OAAZC,WAA0C,YAAA,OAAXC,SACxCA,OAAOD,UAAUD,EAAAA,IACQ,cAAA,OAAXG,UAAyBA,OAAOC,MAC9CD,OAAO,CAAA,GAAIH,CAAAA,IACe,YAAA,OAAZC,UACdA,QAAqB,cAAID,EAAAA,IAEzBD,EAAkB,cAAIC,EAAAA;IACvB,EAAEK,MAAM,WAAA;AACT,cAAA,MAAA;AAAA;AAAA,YAAA,IAAA,CAAA;AAAA,gBAAA,MAAA;AAAA,cAAA,IAAA;ACyEA,mBAASC,EAAqDC,IAAmBC,IAASC,IAAAA;AAExF,mBADAF,GAAOG,iBAAiBF,IAAMC,EAAAA,GACvB,EACLE,SAAS,MAAA;AACFF,cAAAA,MAILF,GAAOK,oBAAoBJ,IAAMC,EAAAA;YAAQ,EAAA;UAG/C;AAAA,iBAAA,eAAA,GAAA,cAAA,EAAA,OAAA,KAAA,CAAA,GAAA,EAAA,cAAA,QAjFA,EAAA,cAAA,MAAA;YAKEI,YAAYN,IAAmBO,IAAAA;AAFvB,mBAAAC,eAA8B,CAAA,GAGpCC,KAAKC,UAAUV,IAEfS,KAAKC,QAAQC,aAAa,eAC1BF,KAAKG,iBAAAA,EAAmBL,MAAAA,UAAWA,GAAQM;YAC7C;YAEOC,SAASC,IAAAA;AACdN,mBAAKD,aAAaQ,KAChBjB,EAAkBU,KAAKC,SAAS,WAAWO,CAAAA,OAAAA;AACzC,sBAAMC,KAA6BD,GAAGC;AACtCH,gBAAAA,GAASI,MAAsB,YAAA,OAATD,KAAoBA,KAAO,IAAIE,WAAWF,EAAAA,CAAAA;cAAM,CAAA,CAAA,GAItET,KAAKG,mBACPH,KAAKD,aAAaQ,KAAKD,GAASM,OAAOH,CAAAA,OAAQT,KAAKa,UAAUJ,EAAAA,CAAAA,CAAAA,GAC9DT,KAAKD,aAAaQ,KAAKD,GAASQ,SAASL,CAAAA,OAAQT,KAAKe,YAAYN,EAAAA,CAAAA,CAAAA,IAGpET,KAAKD,aAAaQ,KAAKjB,EAAkBU,KAAKC,SAAS,SAAS,MAAMD,KAAKL,QAAAA,CAAAA,CAAAA,GAC3EK,KAAKD,aAAaQ,KAAKjB,EAAkBU,KAAKC,SAAS,SAAS,MAAMD,KAAKL,QAAAA,CAAAA,CAAAA;YAC7E;YAEOA,UAAAA;AACL,yBAAWqB,MAAKhB,KAAKD;AACnBiB,gBAAAA,GAAErB,QAAAA;YAEN;YAEQkB,UAAUJ,IAAAA;AACXT,mBAAKiB,iBAAAA,KAGVjB,KAAKC,QAAQiB,KAAKT,EAAAA;YACpB;YAEQM,YAAYN,IAAAA;AAClB,kBAAA,CAAKT,KAAKiB,iBAAAA;AACR;AAEF,oBAAME,KAAS,IAAIR,WAAWF,GAAKW,MAAAA;AACnC,uBAASC,KAAI,GAAGA,KAAIZ,GAAKW,QAAAA,EAAUC;AACjCF,gBAAAA,GAAOE,EAAAA,IAA0B,MAArBZ,GAAKa,WAAWD,EAAAA;AAE9BrB,mBAAKC,QAAQiB,KAAKC,EAAAA;YACpB;YAEQF,mBAAAA;AACN,sBAAQjB,KAAKC,QAAQsB,YAAAA;gBACnB,KAAKC,UAAUC;AACb,yBAAA;gBACF,KAAKD,UAAUE;AACb,wBAAM,IAAIC,MAAM,gDAAA;gBAClB,KAAKH,UAAUI;AAEb,yBADAC,QAAQC,KAAK,gCAAA,GAAA;gBAEf,KAAKN,UAAUO;AACb,wBAAM,IAAIJ,MAAM,+BAAA;gBAClB;AACE,wBAAM,IAAIA,MAAM,yBAAA;cAAA;YAEtB;UAAA;QAAA,GAAA,GAAA;MAAA,GAAA;IAAA,CAAA;;;",
  "names": ["root", "factory", "exports", "module", "define", "amd", "self", "addSocketListener", "socket", "type", "handler", "addEventListener", "dispose", "removeEventListener", "constructor", "options", "_disposables", "this", "_socket", "binaryType", "_bidirectional", "bidirectional", "activate", "terminal", "push", "ev", "data", "write", "Uint8Array", "onData", "_sendData", "onBinary", "_sendBinary", "d", "_checkOpenSocket", "send", "buffer", "length", "i", "charCodeAt", "readyState", "WebSocket", "OPEN", "CONNECTING", "Error", "CLOSING", "console", "warn", "CLOSED"]
}
